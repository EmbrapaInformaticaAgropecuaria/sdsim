% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sdSimulator.R
\name{sdSimulate}
\alias{sdSimulate}
\title{Simulate System Dynamics Models and Static Models}
\usage{
sdSimulate(model, scenario = NULL, from = NULL, to = NULL, by = NULL,
  method = NULL, events = T, maxroots = 100, terminalroot = NULL,
  ties = "notordered", storeAuxTrajectory = T,
  storeTimeSeriesTrajectory = F, verbose = F)
}
\arguments{
\item{model}{A \code{\link{sdModelClass}}, a 
\code{\link{sdCoupledModelClass}} or a \code{\link{sdStaticModelClass}} 
object.}

\item{scenario}{A \code{\link{sdScenarioClass}} object or a character string 
with a scenario XML or EXCEL file name. 

If the \code{model} is a \code{\link{sdCoupledModelClass}} object the 
\code{scenario} must be a coupled scenario object (created with the 
\code{\link{sdBuildCoupledScenario}} function), or a list of 
\code{\link{sdScenarioClass}} objects and/or character strings with a 
scenario XML or EXCEL file name - the elements of this list must be named 
with the component ID that will use it.}

\item{from}{If not missing, overwrites the starting value of the time 
sequence. Of length 1.}

\item{to}{If not missing, overwrites the end (maximal) value of the time 
sequence. Of length 1.}

\item{by}{If not missing, overwrites the increment of the time sequence. 
A number of length 1.}

\item{method}{If not missing, overwrites the integration method.

The integrator to be used in the simulation, a string
("lsoda", "lsode", "lsodes","lsodar","vode", "daspk", "euler",
"rk4", "ode23", "ode45", "radau", "bdf", "bdf_d", "adams", "impAdams" or
"impAdams_d"). Default value is "lsoda".

When running with support to events the given method must
be one of the following routines, which have root-finding capability:
\code{\link[deSolve]{lsoda}}, \code{\link[deSolve]{lsode}} or
\code{\link[deSolve]{radau}}; If the given method is different from any of
these three routines the simulator will run with the default method
"lsoda".

See the \code{\link[deSolve]{ode}} and the \code{\link[deSolve]{events}}
details section for more information.}

\item{events}{logical: if \code{TRUE} run the simulation with support to
events (only if the \code{model} have a root specification); if \code{FALSE} 
do not run the simulation with support to events. Default is \code{TRUE}.}

\item{maxroots}{When events = TRUE and events are triggered by a root, the 
maximal number of times at with a root is found and that are kept; defaults 
to 100. If the number of roots > maxroot, then only the first maxroot will be 
outputted.}

\item{terminalroot}{When events = TRUE and events are triggered by a root, 
the default is that the simulation continues after the event is executed. 
In terminalroot, we can specify which roots should terminate the simulation.}

\item{ties}{When events = TRUE and events are specified by a data.frame and 
are "ordered", set to "ordered". The default is "notordered". 
This will save some computational time.}

\item{storeAuxTrajectory}{logical: if \code{TRUE} record the
\code{model} auxiliary equations trajectories if any (good for visualization,
but loses performance). Default is \code{TRUE}.}

\item{storeTimeSeriesTrajectory}{logical: if \code{TRUE} builds the
time series trajectories if any (good for visualization, but loses
performance). Default is \code{FALSE}.}

\item{verbose}{Logical: If \code{TRUE} provides additional details as to what 
the computer is doing. Default is \code{FALSE}.}
}
\value{
A \code{\link{sdOutput}} object initialized with the simulation 
trajectories.
}
\description{
Simulates a \code{model} using it's default scenario merged
with the given \code{scenario}. A wrapper around the 
\code{\link[deSolve]{ode}} solver.
}
\details{
If performance is crucial remember to garantee that the model is already 
verified and the following logical parameters are set to FALSE: 
storeAuxTrajectory, storeTimeSeriesTrajectory, verbose.
}
\examples{
# Load the Bouncing Ball model from the sdsim repository
bb <- sdLoadModel(file = "BouncingBall", repository = TRUE)

# simulate the model with validation and plot the results
outbb <- sdSimulate(model = bb, verbose = TRUE)
outbb$plot("height speed", multipleYAxis = TRUE, units = TRUE)

# simualte the Bouncing Ball model in a different scenario with the 
# coeficient of restitution equals 0.5 and a shorter time sequence
hardBallScen <- sdScenario(scenarioId = "hardBall", 
                           times = list(to = 5),
                           input = list(k = 0.5))
outbbHard <- sdSimulate(model = bb, scenario = hardBallScen)
plot(outbbHard)
}
