% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sdScenario.R
\name{sdScenarioClass}
\alias{sdScenarioClass}
\title{Class Representation of a System Scenario}
\description{
Represents a system scenario that can consist of state variables, 
inputs, constant values, parameters and switches. It also stores 
configurations for a simulation, e.g. the time sequence and integrator 
method. Together, all the variables and values constitute a system 
environment for a model.
}
\details{
The varible names are coerced to syntatically valid names following the 
criterias described in \code{\link{sdsim-LabelingRules}}.
All the variables, except the \code{state}, accepts vectors. 
All the object field are active binding variables that invoke a function to 
read it's value or to assign a value to it (<-). 

To create an object use the constructor \code{\link{sdScenario}}.

To load a scenario from an EXCEL or XML file use the 
\code{\link{sdLoadScenario}} function.

To build a coupled scenario use the \code{\link{sdBuildCoupledScenario}} 
function.
}
\section{Public Methods Definition}{
  
\describe{
\item{\code{$initialize(id, times, method, state, constant, 
parameter, input, interpolation, switch, unit, description, 
timeSeriesDirectory = "")}}{
Class constructor. Sets the model definition fields.

\strong{Arguments}

\emph{See the Fields section above for the other arguments descriptions.}
\describe{
\item{interpolation}{A list containing the interpolation methods for any time
series variable present the input list. All the elements in this list must be 
named with the respective input time series variable name. See 
\code{\link{sdTemporalFunction}} for the complete list of available methods.}
\item{timeSeriesDirectory}{The directory where the time series inputs are 
stored (when passing the time series inputs via external files).}
}
}

\item{\code{$print()}}{Print the state, constant, parameter, input and switch
data.frames (with variable, value, unit, description and interpolation 
columns).
}

\item{\code{$addState(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named fixed numeric values. If it is a single list, it's 
  elements will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about 
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

\item{\code{$addConstant(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named numeric vectors. If it is a single list, it's elements 
  will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about 
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

\item{\code{$addInput(..., interpolation = NULL, verbose = FALSE, 
overwrite = FALSE, timeSeriesDirectory = "")}}{

\strong{Arguments}

\describe{
  \item{...}{named objects.
  If it is a single list, it's elements will be added instead.}
  \item{interpolation}{A list containing the interpolation methods for any 
  time series variable given in the '...' list. All the elements in this list 
  must be named with the respective time series variable name. See 
  \code{\link{sdTemporalFunction}} for the complete list of available 
  methods.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about 
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
  \item{timeSeriesDirectory}{The directory where time series variables are 
  stored (when passing the time series inputs via external files as character
  file names).}
}}

\item{\code{$addParameter(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named numeric vectors. If it is a single list it's elements 
  will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

\item{\code{$addSwitch(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named numeric or complex or logical or character vectors. 
  If it is a single list it's elements will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about 
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

\item{\code{$addUnit(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named character vectors. 
  If it is a single list it's elements will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

 \item{\code{$addDescription(..., verbose = FALSE, overwrite = FALSE)}}{

\strong{Arguments}

\describe{
  \item{...}{named character vectors. 
  If it is a single list it's elements will be added instead.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about
  the added variable. Default = \code{FALSE}.}
  \item{overwrite}{Logical: If \code{TRUE} overwrittes all the previous added
  variables with the given '...' list. Default = \code{FALSE}.}
}}

\item{\code{$removeState(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the state variable names to be 
  removed. If missing all states will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details about
  the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeConstant(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the constant variable names to be 
  removed. If missing all constants will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeParameter(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the parameter variable names to be 
  removed. If missing all parameters will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeInput(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the input variable names to be 
  removed. If missing all inputs will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeSwitch(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the switch variable names to be 
  removed. If missing all switches will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeUnit(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the variable names to remove the 
  unit. If missing all switches will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$removeDescription(..., verbose = FALSE)}}{
 
\strong{Arguments}

\describe{
  \item{...}{Character objects containing the variable names to remove the 
  description. If missing all switches will be removed.}
  \item{verbose}{Logical: If \code{TRUE} provides additional details 
  about the removed variable. Default = \code{FALSE}.}
}}

\item{\code{$setTimeSequence(from, to, by)}}{Set the simulation time 
sequence.
 
\strong{Arguments}

\describe{
  \item{from}{The simulation initial time; numeric.}
  \item{to}{The simulation final time; numeric.}
  \item{by}{the time step, increment of the sequence}
}}

\item{\code{$buildDataFrames()}}{Build the scenario variables data.frames.
 
\strong{Returned Value}

A list with the state, constant, parameter, input and switch
data.frames (with variable, value, unit, description and interpolation 
columns)}

\item{\code{$saveXlsx(file = "Scenario.xlsx", colWidth = c(10, 10, 10, 30, 
10))}}{Save the scenario variables in a EXCEL file. This format is 
\strong{recommended} for user modification. It will follow the format present 
in the EXCEL Format section of the \code{\link{sdLoadScenario}} help.

\strong{Arguments}

\describe{
\item{file}{A string with the file name to save to. The file extension
must be included in the file name, e.g. '.xlsx'.}
\item{colWidth}{The Excel columns width.}
}}

\item{\code{$saveXml(file = "sdScenario.xml")}}{Save the scenario variables 
in a XML file. This format is \strong{not} recommended for user modification.

\strong{Arguments}

\describe{
\item{file}{A string with the file name to save to. The file extension
must be included in the file name, e.g. '.xml'.}
}}
}
}

\examples{
## Let's create a scenario with two state variables, two input variables (one
# being a time series) and one constant

## First implementation using lists:

# let's create a list for each type of variable (st, inp and ct)
# state variables
st <- list(s1 = 2, s2 = 5)  
# input variables
inp <- list(i1 = 10, ts1 = data.frame(Time = c(1, 5, 10), 
                                     Value = c(5, 10, 20)))
# interpoaltion method for the time series variable
tsInterpolation <- list(ts1 = "linear")
# constant variables
ct <- list(c1 = 0.5)

# let's create dummy descriptions and units for our example variables
descriptions <- list(s1 = "state var 1",
                     s2 = "state var 2",
                     i1 = "input var 1",
                     ts1 = "time series var 1",
                     c1 = "constant var 1")
units <- list(s1 = "meter",
              s2 = "meter / second",
              i1 = "1 / second",
              ts1 = "liters / second",
              c1 = "dimensionless")

# let's create a list for the time sequence and define the integrator method
times <- list(from = 0, to = 10, by = 0.5)
method <- "rk4"
              
# call the constructor to create a scenario from the lists
dummyScen <- sdScenario(id = "dummyScenario",
                        state = st, 
                        input = inp, 
                        interpolation = tsInterpolation,
                        constant = ct,
                        description = descriptions,
                        unit = units,
                        times = times,
                        method = method)
print(dummyScen)

# let's remove the input 'i1' and add it again as a function
dummyScen$removeInput("i1")
dummyScen$addInput(i1 = function(x) {x + 10})
print(dummyScen$input$i1(5))

# let's remove all the state variables and add them again by assignment
dummyScen$removeState()
dummyScen$state <- list(s1 = 2, s2 = 5) 

# let's add the descriptions and units again
dummyScen$addDescription(s1 = "state var 1",
                         s2 = "state var 2",
                         i1 = "input fun 1")
dummyScen$addUnit(s1 = "meter",
                  s2 = "meter / second",
                  i1 = "1 / second")
print(dummyScen)

## Second implementation using data.frames:

# let's create a data.frame for each type of variable
# remember setting stringsAsFactor = FALSE to prevent wrong convertions

# state variables
st <- data.frame(Variable = c("s1", "s2"), 
                 Value = c(5,10),
                 Description = c("state var 1", "state var 2"),
                 Unit = c("meter", "meter / second"),
                 stringsAsFactors = FALSE)

# input variables
inp <- data.frame(Variable = c("i1", "ts1"), 
                 Value = c(10, "data.frame(Time = c(1, 5, 10), 
                                           Value = c(5, 10, 20))"),
                 Interpolation = c(NA, "linear"),
                 Description = c("input var 1", "time series var 1"),
                 Unit = c("1 / second", "liters / second"),
                 stringsAsFactors = FALSE)
     
# constant variables
ct <- data.frame(Variable = c("c1"), 
                 Value = c(0.5),
                 Description = c("constant var 1"),
                 Unit = c("dimensionless"),
                 stringsAsFactors = FALSE)

# call the constructor to create a scenario from the data.frames
dummyScen <- sdScenario(id = "dummyScenario",
                        state = st, 
                        input = inp, 
                        constant = ct,
                        times = times,
                        method = method) 
print(dummyScen)
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{id}}{A string with the scenario identification. If missing a 
default timestamp will be created.}

\item{\code{times}}{A named list containing three elements to be passed to 
the \code{\link{seq}} function: from - the simulation initial time, to - the 
simulation final time and by - the simulation time step, increment of the 
sequence (e.g.list(from = 0, to = 100, by = 1)).}

\item{\code{method}}{The default integrator to be used in the simulations, 
a string ("lsoda", "lsode", "lsodes","lsodar","vode", "daspk", "euler", 
"rk4", "ode23", "ode45", "radau", "bdf", "bdf_d", "adams", "impAdams" or 
"impAdams_d").

When running with support to events the given method must be one of the 
following routines, which have root-finding capability: 
\code{\link[deSolve]{lsoda}}, \code{\link[deSolve]{lsode}} or
\code{\link[deSolve]{radau}}; If the given method is different from any of 
these three routines the simulator will run with the default method 
"lsoda". 

See the \code{\link[deSolve]{ode}} and the \code{\link[deSolve]{events}} 
details section for more information.}

\item{\code{state}}{A numeric list with the default initial state values for an ODE 
system. The state variables are used to describe the mathematical "state" of 
a system dynamics. The continuous rate of change of these variables 
is determined by the model \code{ode} function. All the 
elements in this list must be named.}

\item{\code{constant}}{A numeric list with the model constant variables. 
All the elements in the list must be named.}

\item{\code{parameter}}{A numeric list containing the parameters of the 
scenario. All the elements in this list must be named.}

\item{\code{input}}{A list with the input variables. It accepts any type of
elements. The time series variables must be present in this list. All the 
elements in this list must be named.

If any interpolation method is given in the object initialization it will be 
stored in the input list element 'interpolation_' and the transformed 
temporal functions, created with the \code{\link{sdTemporalFunction}}, will 
be stored in the element 'fun_'.}

\item{\code{switch}}{A list with the switch variables. All the elements in 
this list must be named.}

\item{\code{unit}}{A list with the model variables units. Each element of
this list represents a variable (named with the variable name) and it's 
value is a string with the variable unit.}

\item{\code{description}}{A list with the model variables descriptions. 
Each element of this list represents a variable (named with the variable 
name) and it's value is the variable description.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{sdScenarioClass$new()}}
\item \href{#method-print}{\code{sdScenarioClass$print()}}
\item \href{#method-saveXml}{\code{sdScenarioClass$saveXml()}}
\item \href{#method-saveXlsx}{\code{sdScenarioClass$saveXlsx()}}
\item \href{#method-setTimeSequence}{\code{sdScenarioClass$setTimeSequence()}}
\item \href{#method-addState}{\code{sdScenarioClass$addState()}}
\item \href{#method-addConstant}{\code{sdScenarioClass$addConstant()}}
\item \href{#method-addInput}{\code{sdScenarioClass$addInput()}}
\item \href{#method-addParameter}{\code{sdScenarioClass$addParameter()}}
\item \href{#method-addSwitch}{\code{sdScenarioClass$addSwitch()}}
\item \href{#method-addDescription}{\code{sdScenarioClass$addDescription()}}
\item \href{#method-addUnit}{\code{sdScenarioClass$addUnit()}}
\item \href{#method-removeState}{\code{sdScenarioClass$removeState()}}
\item \href{#method-removeConstant}{\code{sdScenarioClass$removeConstant()}}
\item \href{#method-removeInput}{\code{sdScenarioClass$removeInput()}}
\item \href{#method-removeParameter}{\code{sdScenarioClass$removeParameter()}}
\item \href{#method-removeSwitch}{\code{sdScenarioClass$removeSwitch()}}
\item \href{#method-removeDescription}{\code{sdScenarioClass$removeDescription()}}
\item \href{#method-removeUnit}{\code{sdScenarioClass$removeUnit()}}
\item \href{#method-buildDataFrames}{\code{sdScenarioClass$buildDataFrames()}}
\item \href{#method-clone}{\code{sdScenarioClass$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$new(
  id,
  times,
  method,
  state,
  constant,
  parameter,
  input,
  interpolation,
  switch,
  unit,
  description,
  timeSeriesDirectory = "",
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saveXml"></a>}}
\if{latex}{\out{\hypertarget{method-saveXml}{}}}
\subsection{Method \code{saveXml()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$saveXml(file = "Scenario.xml")}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saveXlsx"></a>}}
\if{latex}{\out{\hypertarget{method-saveXlsx}{}}}
\subsection{Method \code{saveXlsx()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$saveXlsx(
  file = "Scenario.xlsx",
  colWidth = c(10, 10, 10, 30, 10)
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setTimeSequence"></a>}}
\if{latex}{\out{\hypertarget{method-setTimeSequence}{}}}
\subsection{Method \code{setTimeSequence()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$setTimeSequence(from, to, by)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addState"></a>}}
\if{latex}{\out{\hypertarget{method-addState}{}}}
\subsection{Method \code{addState()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addState(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addConstant"></a>}}
\if{latex}{\out{\hypertarget{method-addConstant}{}}}
\subsection{Method \code{addConstant()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addConstant(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addInput"></a>}}
\if{latex}{\out{\hypertarget{method-addInput}{}}}
\subsection{Method \code{addInput()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addInput(
  ...,
  interpolation = NULL,
  verbose = FALSE,
  overwrite = FALSE,
  timeSeriesDirectory = ""
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addParameter"></a>}}
\if{latex}{\out{\hypertarget{method-addParameter}{}}}
\subsection{Method \code{addParameter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addParameter(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSwitch"></a>}}
\if{latex}{\out{\hypertarget{method-addSwitch}{}}}
\subsection{Method \code{addSwitch()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addSwitch(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addDescription"></a>}}
\if{latex}{\out{\hypertarget{method-addDescription}{}}}
\subsection{Method \code{addDescription()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addDescription(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addUnit"></a>}}
\if{latex}{\out{\hypertarget{method-addUnit}{}}}
\subsection{Method \code{addUnit()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$addUnit(..., verbose = FALSE, overwrite = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeState"></a>}}
\if{latex}{\out{\hypertarget{method-removeState}{}}}
\subsection{Method \code{removeState()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeState(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeConstant"></a>}}
\if{latex}{\out{\hypertarget{method-removeConstant}{}}}
\subsection{Method \code{removeConstant()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeConstant(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeInput"></a>}}
\if{latex}{\out{\hypertarget{method-removeInput}{}}}
\subsection{Method \code{removeInput()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeInput(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeParameter"></a>}}
\if{latex}{\out{\hypertarget{method-removeParameter}{}}}
\subsection{Method \code{removeParameter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeParameter(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeSwitch"></a>}}
\if{latex}{\out{\hypertarget{method-removeSwitch}{}}}
\subsection{Method \code{removeSwitch()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeSwitch(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeDescription"></a>}}
\if{latex}{\out{\hypertarget{method-removeDescription}{}}}
\subsection{Method \code{removeDescription()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeDescription(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeUnit"></a>}}
\if{latex}{\out{\hypertarget{method-removeUnit}{}}}
\subsection{Method \code{removeUnit()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$removeUnit(..., verbose = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-buildDataFrames"></a>}}
\if{latex}{\out{\hypertarget{method-buildDataFrames}{}}}
\subsection{Method \code{buildDataFrames()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$buildDataFrames(showId = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdScenarioClass$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
