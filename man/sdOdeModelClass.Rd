% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sdOdeModel.R
\name{sdOdeModelClass}
\alias{sdOdeModelClass}
\title{Class Representation of an Atomic System Dynamics Model}
\description{
Represents an atomic system dynamics model that consists of functions 
describing the system flows and a default scenario describing the system 
environment (variables and values). 
All the object field are active binding variables that invoke a function to 
read it's value or to assign a value to it (<-).
}
\details{
To create an object use the constructor \code{\link{sdOdeModel}}.

To load a model from a XML file use the \code{\link{sdLoadModel}} function.

To simulate a model in different scenarios use the \code{\link{sdSimulate}}
function.
}
\section{Public Methods Definition}{
  
\describe{
\item{\code{$initialize(id, description, ode, 
initVars, postProcess, trigger, event, aux, 
defaultScenario, globalFunctions)}}{
Class constructor. Sets the model definition fields.

\strong{Arguments}

\emph{See the Fields section above for the arguments descriptions.}
}

\item{\code{$print()}}{Print the object fields.}

\item{\code{$verifyModel(scenario = NULL, verbose = F)}}{
Execute the model simulation first step in the default scenario or merged 
with a given one. Check for possible incorrect variables and warn the user.

\strong{Arguments}

\describe{
\item{scenario}{A \code{\link{sdScenarioClass}} object or a character string 
naming the sdScenario XML or EXCEL file. If missing validate the model using
the default scenario.}
\item{verbose}{Logical: If \code{TRUE} provides additional details as to what 
the computer is doing. Default = \code{FALSE}.}
}}
 
\item{\code{$saveXml(file = "sdOdeModel.xml")}}{Save the model functions in a 
XML file.

\strong{Arguments}

\describe{
\item{file}{A string with the file name to save to. The file extension
must be included in the file name, e.g. '.xml'.}
}} 
}
}

\examples{
## HOW TO CREATE A MODEL
## The Lotka-Volterra consumer-prey model

# parameters in a list with units and descriptions in separete lists
pars      <- list(rI = 0.2,
                  rG = 1.0,    
                  rM = 0.2 ,   
                  AE = 0.5,    
                  K  = 10)   
parsUnits <- list(rI = "1/day",    
                  rG = "1/day",   
                  rM = "1/day" ,   
                  AE = "dimensionless",    
                  K  = "mmol/m3")
parsDescription <- list(rI = "rate of ingestion",    
                        rG = "growth rate of prey",   
                        rM = "mortality rate of consumer" ,   
                        AE = "assimilation efficiency",    
                        K  = "carrying capacity")

# state variables in a data.frame with values and description
st <- data.frame(Variable = c("P", "C"), 
                 Value = c(1, 2), 
                 Description = c("Prey", "Consumer"))

# time sequence
times <- list(from = 0, to = 200, by = 1)

# auxiliary equations
aux <- list(IngestC = "par$rI * st$P * st$C",
            GrowthP = "par$rG * st$P * (1 - st$P/par$K)",
            "MortC <- par$rM * st$C")

# differential equations
LVode <- function(t, st, ct, par, inp, sw, aux) 
{
  dP    <- aux$GrowthP - aux$IngestC
  dC    <- aux$IngestC * par$AE - aux$MortC
  
  return(list(c(dP, dC)))
}

# create the scenario
lvscen <- sdScenario(id = "LVscen", times = times, method = "lsoda",
                     state = st, parameter = pars, 
                     unit = parsUnits, description = parsDescription)

# create the model object
lv <- sdOdeModel(id = "Lotka-Volterra", defaultScenario = lvscen, 
              ode = LVode,
              aux = aux)
              
# validate the model ode
lv$verifyModel(verbose = TRUE)

# simulate the model and plot the results
outlv <- sdSimulate(model = lv, storeAuxTrajectory = TRUE)
outlv$plot("P C", multipleYAxis = TRUE, 
           main = "Prey and Consumer by Lotka-Volterra")
outlv$saveSimulationOutput(path = "LV")

## HOW TO LOAD A MODEL FROM THE REPOSITORY
## Load the Rigid Body Model
rb <- sdLoadModel(file = "RigidBody", repository = TRUE)
print(rb)

# simulate the model and plot the results
outrb <- sdSimulate(model = rb)
outrb$plot("x y z")
}
\section{Super class}{
\code{\link[sdsim:sdModel]{sdsim::sdModel}} -> \code{sdOdeModel}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{id}}{A string with the model identification. It is coerced to a valid id 
following the rules described in \code{\link{sdsim-LabelingRules}}.}

\item{\code{description}}{A string with the model description.}

\item{\code{defaultScenario}}{The model default scenario, a 
\code{\link{sdScenarioClass}} object. It should contain all the model
variables initialized with default values that ensures the model simulation.}

\item{\code{description}}{A list with the model dafault scenario variables 
descriptions. 
Each element of this list represents a variable (named with the variable 
name) and it's value is the variable description.}

\item{\code{unit}}{A list with the model dafault scenario variables units. Each 
element of this list represents a variable (named with the variable name) 
and it's value is a string with the variable unit.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{id}}{A string with the model identification. It is coerced to a valid id 
following the rules described in \code{\link{sdsim-LabelingRules}}.}

\item{\code{description}}{A string with the model description.}

\item{\code{defaultScenario}}{The model default scenario, a 
\code{\link{sdScenarioClass}} object. It should contain all the model
variables initialized with default values that ensures the model simulation.}

\item{\code{aux}}{(Optional) A list with the model auxiliary equations in strings or 
R-expressions written in R-format to assist in the 
\code{ode} computation.

They have access to the following variables: (t, st, ct, par, inp, sw, aux). 
Where \code{t} is 
the current time point in the integration, \code{st} is a list with the 
current estimate of the state variables in the ODE system, \code{ct} is a 
list with the model constant variables, \code{par} is a list with the model 
parameter variables, \code{inp} is a list with the model input variables with 
the time series variables evaluated for the current time step, \code{sw} is 
list with the model switch variables and \code{aux} is a list with the 
predecessors auxiliary equations, following the sorted list, evaluated for 
the current time step. 

The auxiliary equations are evaluated at each time step during simulations 
and passed via the argument \code{aux} to any model function call.  

See the function \code{\link{sdInitEquations}} to learn how this list is 
generated.}

\item{\code{ode}}{An R-function that computes the values of the 
state variables derivatives in the ODE system (the model definition) at time 
t.

It must be defined as: ode <- function(t, st, ct, par, inp, 
sw, aux). 
Where \code{t} is the current time point in the integration, \code{st} is 
a list with the current estimate of the state variables in the ODE system, 
\code{ct} is a list with the model constant variables, \code{par} is
a list with the model parameter variables, \code{inp} is a list with the
model input variables and the time series variables evaluated for the 
current time step, \code{sw} is  list with the model switch variables and
\code{aux} is a list with the model auxiliary equations evaluated for the 
current time step.


The return value of \code{ode} must be a list, whose first 
element is a vector containing the derivatives of the state variables with 
respect to time, and whose next elements are extra values that are 
computed at each time step and will be included in the simulation output. The 
derivatives must be specified in the same order as the state variables.}

\item{\code{initVars}}{(Optional) An R-function that initialize or change the 
initial state values and/or other model variables before the solver call when
running a simulation. 
It can be used, for example, to compute some dependent parameter variables or 
the initial state variables, using the arguments. 

It must be defined as: function(st, ct, par, inp, sw, aux). Where \code{st} is 
a list with the initial state variables values, \code{ct} is a list with the 
model constant variables, \code{par} is a list with the model parameter
variables, \code{inp} is a list with the model input variables, \code{sw} is
a list with the model switch variables and \code{aux} is a list with the 
model auxiliary equations in R-expression format, as defined by the user.

The return value of the \code{initVars} function should be a list containing 
all the function arguments, except the aux equations, named in the same way, 
e.g. \code{return(list(st = st, ct = ct, inp = inp, par = par, sw = sw))}.}

\item{\code{postProcess}}{(Optional) An R-function that receives the simulation 
output inside the \code{sdSimulate} function and process it to derive further 
conclusions. 

It must be defined as: function(outputTrajectory, auxTrajectory, 
tsTrajectory, ct, par, inp, sw). 
Where \code{outputTrajectory} is a data.frame with the 
\code{\link[deSolve]{ode}} output trajectory, 
\code{auxTrajectory} is a data.frame with the auxiliary equations trajectory, 
\code{tsTrajectory} is a data.frame with the time series variables 
trajectory, \code{ct} is a list with the model constant variables, \code{par} 
is a list with the model parameter variables, \code{inp} is a list with the 
model input variables and \code{sw} is a list with the model switch 
variables.

The return value of \code{postProcess} will be stored in the postProcess
field of the \code{\link{sdOutput}} simulation output object and can be 
anything that suits the user needs.}

\item{\code{trigger}}{(Optional) A numeric vector containing the times to 
trigger the \code{event}, or a data.frame as specified in the 
\code{\link[deSolve]{events}} documentation, or an R-function that becomes 
zero when a root occur. 

When a root is found, the simulation triggers an event by calling 
the \code{event}. If no \code{event} is defined, when a root 
is found the simulation stops. 

When specified as a function it must be defined as: function(t, st, ct, par, 
inp, sw, aux). 
Where \code{t} is the current time point in the integration, \code{st} is 
a list with the current estimate of the state variables in the ODE system, 
\code{ct} is a list with the model constant variables, \code{par} is
a list with the model parameter variables, \code{inp} is a list with the
model input variables with the time series variables evaluated for the 
current time step, \code{sw} is list with the model switch variables and
\code{aux} is a list with the model auxiliary equations evaluated for the 
current time step.

It should return a numeric vector. If any element of this vector is zero an 
event is trigged.}

\item{\code{event}}{(Optional) An R-function that specifies the event. 

It must be defined as: function(t, st, ct, par, inp, sw, aux). 
Where \code{t} is the current time point in the integration, \code{st} is 
a list with the current estimate of the state variables in the ODE system, 
\code{ct} is a list with the model constant variables, \code{par} is
a list with the model parameter variables, \code{inp} is a list with the
model input variables with the time series variables evaluated for the 
current time step, \code{sw} is  list with the model switch variables and
\code{aux} is a list with the model auxiliary equations evaluated for the 
current time step. 

It should return the state-values (some of which modified), as a vector with 
the variables in the right order. If no \code{event} is defined, when 
a root is found the simulation stops.}

\item{\code{description}}{A list with the model dafault scenario variables 
descriptions. 
Each element of this list represents a variable (named with the variable 
name) and it's value is the variable description.}

\item{\code{unit}}{A list with the model dafault scenario variables units. Each 
element of this list represents a variable (named with the variable name) 
and it's value is a string with the variable unit.}

\item{\code{globalFunctions}}{A named list of extra functions that can be executed 
in the scope of any other function or auxiliary equation defined in the 
model. They can be called using the list names.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{sdOdeModelClass$new()}}
\item \href{#method-print}{\code{sdOdeModelClass$print()}}
\item \href{#method-verifyModel}{\code{sdOdeModelClass$verifyModel()}}
\item \href{#method-saveXml}{\code{sdOdeModelClass$saveXml()}}
\item \href{#method-clone}{\code{sdOdeModelClass$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdOdeModelClass$new(
  id,
  description,
  defaultScenario,
  aux,
  ode,
  initVars,
  postProcess,
  trigger,
  event,
  globalFunctions
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdOdeModelClass$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-verifyModel"></a>}}
\if{latex}{\out{\hypertarget{method-verifyModel}{}}}
\subsection{Method \code{verifyModel()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdOdeModelClass$verifyModel(scenario = NULL, verbose = F)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saveXml"></a>}}
\if{latex}{\out{\hypertarget{method-saveXml}{}}}
\subsection{Method \code{saveXml()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdOdeModelClass$saveXml(file = "sdOdeModel.xml")}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sdOdeModelClass$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
